# MySQL

## 基本概念

关系型数据库：逻辑上为二维表格，每一列代表数据的一个属性，每一行代表数据的一个实体

非关系型数据库：逻辑上可以是非二维表格的任何形式

## 三大范式

在数据库设计中，为减少数据冗余，一般会遵循三大范式：

1. 表的每列都是不可再分的原子值
2. 所有非主属性必须依赖整个主键（主要针对复合主键的表）
3. 所有非主属性必须直接依赖主键（非主属性之间不能有依赖关系）

在实际的数据库设计中，有时会故意违反第三范式，以减少查询时的 JOIN 操作

## COUNT(\*) COUNT(数字) COUNT(字段)

COUNT(\*) 和 COUNT(数字) 都是统计行数

COUNT(字段) 只统计该字段非空的行数

因为 COUNT(字段) 要读字段的值，所以效率低于 COUNT(\*) 和 COUNT(数字)

## SQL逻辑顺序

1. FROM JOIN
2. WHERE
3. GROUP BY
4. AGG FUNC
5. HAVING
6. SELECT
7. DISTINCT
8. ORDER BY
9. LIMIT OFFSET

## 索引

索引：通过维护额外的结构，提高查询性能，避免全表扫描

MySQL 的默认存储引擎 InnoDB 采用了 B+ 树作为索引的数据结构

- 主键索引（聚簇索引）：叶子结点存放实际数据
- 二级索引（非聚簇索引）：叶子结点存放主键，查询时可能需要回表

B+ 树和 B 树的区别

- B+ 树只在叶子结点存放数据，内部结点可以存更多的 key，树高更矮
- B+ 树所有叶子结点是相连的，便于范围查询

索引失效的场景

- 左模糊匹配
- 对索引列使用函数或表达式
- 使用复合索引时未遵循最左匹配原则

索引的使用场景

- 唯一性字段
- 经常 WHERE、GROUP BY、ORDER BY 的字段

## 事务

核心特性：ACID

- 原子性：要么不做要么全做
- 一致性：从一个合法状态转移到另一个合法状态
- 隔离性：事务之间互相隔离
- 持久性：事务提交则永久保存

多个事务并发执行时可能出现的问题

- 脏读：读到未提交的数据
- 不可重复读：同一事务内多次读同一行，结果不同
- 幻读：同一查询多次执行，返回的行数不同

四种隔离级别

- READ UNCOMMITED：可能出现脏读、不可重复读、幻读
- READ COMMITED：可能出现不可重复读、幻读
- REPEATABLE READ：可能出现幻读（MySQL 中不会）
- SERIALIZABLE

## 锁



## 日志



## 主从复制



## 性能优化



## 分库分表



# Redis

## 基本概念

Redis 是一种内存数据库，常用作数据库的缓存

Redis 存储的是键值对

- key 固定是字符串
- value 可以是字符串、哈希表、列表、集合、有序集合等

## Redis为什么快

### 命令执行

Redis 执行命令是单线程的，避免了多线程竞争的开销

Redis 命令主要是内存操作，瓶颈在内存而非 CPU，所以单线程执行也很快

### 数据结构

Redis 内部实现了很多高效的数据结构

### 网络IO

Redis 使用了 IO 多路复用来管理连接，具有良好的 IO 吞吐量

早期版本中，网络 IO 和命令执行都在同一个线程，现在 Redis 的网络 IO 是多线程的

## 缓存三剑客

缓存三剑客描述了三种数据库被打穿的场景

缓存雪崩

- 大量 key 同时过期
- 解决方案：过期时间加随机值

缓存击穿

- 热 key 过期
- 解决方案：只允许第一个请求访问数据库并缓存

缓存穿透

- 请求的 key 不在缓存，也不在数据库
- 解决方案：缓存空值

## 持久化

Redis 提供了两种持久化方案

- RDB：全量刷盘
- AOF：记录写操作

## 主从复制

Redis 的主从复制是异步的，在 CAP 定理中属于 AP 模型（etcd 是 CP 模型）

## 哨兵



## 分片集群



