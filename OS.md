# Linux环境

## git

git 是一个版本管理工具

- git clone xxx（仅第一次）
- git checkout -b feat
- 写代码
- git add xxx
- git commit -m "xxx"
- git checkout main
- git pull origin main
- git checkout feat
- git rebase main
- git push origin feat
- 提 PR
- git push -d origin feat
- git checkout main
- git branch -D feat
- git pull origin main

## perf

perf 是一个性能分析工具

- 编译时加 -g -O2 选项
- perf stat -a xxx
- perf record -g xxx
- perf report

# 基础知识

## 操作系统是什么

操作系统是一款管理软硬件资源、给用户提供基本抽象的软件

```
API
 |
OS
 |
驱动
 |
设备控制器
 |
设备
```

## 用户态和内核态

用户态和内核态是操作系统的两种运行模式

- 用户态不能直接访问硬件或执行特权指令
- 内核态可以直接访问硬件、执行所有指令

通过区分用户态和内核态，可以更好的控制权限，提高操作的安全性

用户态切换到内核态的方式：系统调用、中断、异常

## 进程线程

进程是资源分配的基本单位，每个进程都有自己的地址空间、页表、文件描述符表等资源，创建/销毁/切换的开销较大

线程是系统调度的基本单位，共享进程的大部分资源，只有自己的栈和寄存器，创建/销毁/切换的开销较小

多进程一般用于多个独立的任务，多线程一般用于高并发任务

## 死锁

死锁是指多个线程由于争夺资源而陷入互相等待的僵局，有四个必要条件：

- 互斥条件
- 请求与保持条件
- 不可剥夺条件
- 循环等待条件

怎么解决死锁：破坏死锁的任意一个必要条件即可

- 固定锁的获取顺序，破坏循环等待条件
- 设置超时时间，破坏请求与保持条件

怎么排查死锁：调试观察线程持有的锁和等待的锁，找出循环等待链

## 虚拟内存

虚拟内存是操作系统提供的一种抽象，使得每个进程都有独立的地址空间

- 内核空间：只有内核态能访问，存放内核的代码和数据结构
- 用户空间
	- 栈：用于函数调用，存放函数参数、返回地址、局部变量等，向低地址增长
	- 内存映射区：mmap 作用的区域，包括文件映射和匿名映射
	- 堆：用于动态分配，向高地址增长
	- 数据段：存放全局数据和静态数据
	    - .bss 段：无初始值，只记录大小，程序加载时初始化成 0
	    - .data 段：有初始值，会占用硬盘空间来存储初始值数据
  - 代码段：存放编译后的机器码，通常是只读的

虚拟内存的作用

- 多了一层虚拟地址，可以更好的控制访存安全
- 可以利用硬盘的空间，增加可用内存的大小

## 分页机制

分页是把地址空间划分为固定大小的页（通常为 4KB），每个页通过页表映射到物理内存中

当内存不足时，操作系统会根据特定的淘汰策略，选择一个页面换出到硬盘

- RAND：随机
- FIFO：先进先出
- LFU：最少使用
- LRU：最近最少使用

当页面置换也无法满足内存申请时，内核会触发 OOM 杀进程

# 进程间通信

## 管道

管道分为匿名管道和命名管道，匿名管道只能用于父子进程之间通信，命名管道可以用于任意进程之间通信

管道本质是通过一块内核缓冲区传输字节流，命名管道文件的作用是作为一个标识符，让进程能访问到这块缓冲区

## 共享内存

共享内存就是将同一块物理内存映射到多个进程的用户空间，是最快的进程间通信方式

共享内存不提供同步机制，需要调用方自己处理

## 信号

信号是一种事件通知机制，有三种处理方式：忽略、捕捉、默认

不能忽略或捕捉的两个信号：SIGKILL、SIGSTOP

## 信号量

信号量是一种同步机制，本质是一个计数器，通过两个原子操作控制对共享资源的访问

- 信号量 \>= 0 时表示可访问资源的数量
- 信号量 < 0 时表示阻塞线程的数量

## Socket

Socket 是操作系统提供的一套 API，可以实现跨主机的进程间通信，也可用于本地进程间通信

- TCP 通信
	- 服务器：socket - bind - listen - accept - send/recv - close
	- 客户端：socket - connect - send/recv - close
- UDP 通信
	- 服务器：socket - bind - sendto/recvfrom - close
	- 客户端：socket - sendto/recvfrom - close
- 本地进程通信
	- 服务器：socket - bind - listen - accept - send/recv - close
	- 客户端：socket - connect - send/recv - close

# 网络IO

## IO模型

IO 可以分为两个阶段：准备数据、拷贝数据

- 同步 IO 模型：由进程主动拷贝数据
	- 阻塞 IO、非阻塞 IO、信号驱动 IO、IO 多路复用
- 异步 IO 模型：由内核完成所有操作
	- 异步 IO

## IO多路复用

IO 多路复用就是用一个线程同时监听多个 fd，可以大幅提高 IO 吞吐量

- select
	- 将需要监听的 fd 集合拷贝到内核空间，由内核轮询监听
	- 内核标记就绪的 fd，将 fd 集合拷贝回用户空间
	- 用户通过遍历 fd 集合获取就绪的 fd
	- 总结：最大 fd 数有限、拷贝开销大、O(n) 获取就绪 fd
- poll
	- 与 select 类似，不同的是 poll 的 fd 数量不受限
	- 总结：fd 数不受限、拷贝开销大、O(n) 获取就绪 fd
- epoll
	- 内核使用红黑树保存需要监听的 fd，高效增删查改，无需每次拷贝整个 fd 集合
	- 通过回调将就绪的 fd 加入就绪链表，返回给用户，用户可以 O(1) 获取就绪的 fd
	- 除了 LT，还支持 ET
		- LT：有数据就触发
		- ET：有新数据才触发，可以减少触发次数
	- 总结：fd 数不受限、拷贝开销小、O(1) 获取就绪 fd、支持 ET
