# 基础知识

## TCP/IP模型

### 应用层

对应 OSI 模型的应用层、表示层和会话层，负责给应用程序提供网络服务（HTTP、DNS 等）

应用层工作在用户态，其他层工作在内核态

### 传输层

对应 OSI 模型的传输层，负责端到端的数据传输（TCP、UDP 等）

TCP 是可靠的、面向连接的、基于字节流的，适合需要可靠传输的场景（邮件、文件）

UDP 是不可靠的、无连接的、基于数据报的，适合需要高实时性的场景（直播、游戏）

### 网络层

对应 OSI 模型的网络层，负责跨网络的寻址路由（IP、ICMP 等）

IP 地址：

- 由网络号和主机号组成，IPv4 地址大小为 32 位，IPv6 地址大小为 128 位
- IP 地址 & 子网掩码得到网络号，剩下的就是主机号
- 主机号全 0 代表这个局域网，主机号全 1 代表广播地址

### 链路层

对应 OSI 模型的数据链路层和物理层，负责网络中的数据传输

链路层工作在硬件层次，使用 MAC 地址来标识网络设备

## 报文的封装和分用

不同协议层传输的数据都可以叫报文，报文可以看成该层的报头 + 上层的报文

发送端发送消息时，自顶向下每层协议会给报文添加自己的报头

接收端接收消息时，自底向上每层协议会对报文进行解包分用

# HTTP

## 常见请求方法

GET：获取资源

POST：创建资源

PUT：更新资源

DELETE：删除资源

## GET和POST的区别

GET 通过 URL 传参，受 URL 长度限制

POST 通过请求体传参，理论上没有长度限制

GET 是幂等的，多次请求不会改变服务器状态，可以缓存

POST 不一定幂等，多次请求可能改变服务器状态，一般不缓存

## 常见状态码

1xx：信息性状态码

2xx：成功

- 200 OK：请求成功，服务器返回了所请求的资源
- 204 No Content：请求成功，但没有内容返回

3xx：重定向

- 301 Moved Permanently：请求的资源已被永久移动到新的 URL
- 302 Found：请求的资源临时从其他 URL 响应

4xx：客户端错误

- 400 Bad Request：无效请求
- 404 Not Found：请求的资源未找到

5xx：服务器错误

- 500 Internal Server Error：服务器内部错误
- 502 Bad Gateway：服务器作为网关或代理，访问上游服务器出错

## HTTP/1.0

1. 短连接
2. 请求的队头阻塞

## HTTP/1.1

1. 长连接
2. 解决了请求的队头阻塞，但没有解决响应的队头阻塞

## HTTPS

HTTPS 在 TCP 握手之后还要进行 TLS 握手

1. 客户端发起请求，内容包括支持的加密套件和一个随机数
2. 服务器返回 CA 证书、选择的加密套件和一个随机数
3. 客户端校验证书，生成预主密钥，用证书中的公钥加密后发给服务器（非对称加密）
4. 服务器用私钥解密得到预主密钥

双方通过两个随机数和预主密钥生成会话密钥，后续通信使用会话密钥进行加密（对称加密）

## HTTP/2

1. 头部压缩：压缩重复的头部字段
2. 二进制分帧：将消息拆分成二进制帧
3. 多路复用：多个流的帧可以在同一条连接上并发传输，接收方根据帧上的流 ID 来组装消息
4. 解决了 HTTP 的队头阻塞，但没有解决 TCP 的队头阻塞（丢包会阻塞所有流）

## HTTP/3

1. 采用基于 UDP 的 QUIC 协议，彻底解决 TCP 的队头阻塞
2. QUIC 的特性
	- 丢包只阻塞对应的流
	- 整合 TLS 握手，提高建立连接的速度
	- 连接 ID 与 IP 地址解耦，网络切换无需重新握手

# TCP

## TCP为什么可靠

序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制

## 序列号

序列号用于标识发送数据的每个字节，初始序列号随机生成，每发送一个字节的数据，使得下一次发送的数据的序列号加一

## 确认应答

确认号表示下次期望收到的数据的序列号，确认号之前的数据被认为正常接收

## 超时重传

发送方一定时间内未收到 ACK，会触发重传，重传报文的序列号不变

每次超时时间是上一次的两倍，达到最大重传次数后，自动关闭连接

## 三次握手

三次握手建立连接：

1. 客户端发送 SYN
    - 客户端进入 SYN-SENT 状态
2. 服务器收到 SYN，回复 ACK+SYN
    - 服务器进入 SYN-RCVD 状态
3. 客户端收到 ACK+SYN，返回 ACK
    - 客户端进入 ESTABLISHED 状态
4. 服务器收到 ACK
    - 服务器进入 ESTABLISHED 状态

三次握手的作用：保证双方都有发送和接收的能力

为什么不是两次：防止历史连接被错误建立

- 考虑旧 SYN 比新 SYN 先到达服务器
- 服务器对旧 SYN 回复 ACK+SYN，进入 SYN-RCVD 状态
- 客户端收到 ACK 发现确认号对不上，返回 RST
- 服务器收到 RST 就会释放历史连接，由最新的 SYN 来建立连接
- 如果是两次握手，服务器就没有一个中间状态（SYN-RCVD）来阻止历史连接

四次握手可以吗：可以，但是 ACK+SYN 一般可以优化成一步

## 四次挥手

四次挥手关闭连接：

1. 主动关闭方发送 FIN，进入 FIN_WAIT_1 状态
2. 被动关闭方收到 FIN，回复 ACK，进入 CLOSE_WAIT 状态，继续处理没发完的数据；主动关闭方收到 ACK，进入 FIN_WAIT_2 状态
3. 被动关闭方处理完数据，返回 FIN，进入 LAST_ACK 状态
4. 主动关闭方收到 FIN，回复 ACK，进入 TIME_WAIT 状态，等待 2MSL 时间，之后进入 CLOSE 状态；被动关闭方收到 ACK，进入 CLOSE 状态

三次挥手可以吗：中间两次挥手可能可以合并，取决于被动关闭方是否还有数据要发送

TIME_WAIT 的作用：

- 确保最后的 ACK 到达
- 使该连接上的所有报文都失效

## 流量控制

TCP 在发送方维护了一个滑动窗口，根据接收方接收能力控制发送的数据量

- 已确认 | 允许发送 | 不允许发送
- 接收方通过报头的窗口大小字段告知发送方自己能接收的数据量

## 拥塞控制

TCP 在发送方维护了一个拥塞窗口，根据网络负载控制发送的数据量

- 慢启动
- 拥塞避免
- 快速重传
- 快速恢复

## 发送窗口到底多大

发送窗口大小 = min( 滑动窗口大小, 拥塞窗口大小 )

## UDP为什么不可靠

主要有两个原因

- 不能保证数据顺序
- 不能保证数据到达

## UDP怎么实现可靠传输

在应用层实现可靠特性

- 引入序列号，保证数据顺序
- 引入确认应答和超时重传，保证数据到达
